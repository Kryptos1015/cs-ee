%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[12pt]{article}

\input{structure.tex} % Include the file specifying the document structure and custom commands

%----------------------------------------------------------------------------------------
%	ASSIGNMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{\textbf{Comparing and Analyzing the Effectiveness of Various String Matching Algorithms Across Different Domains}} % Title of the assignment

\author{\textbf{Research Question -} How do different string \and matching algorithms perform across various application domains, \and and what factors contribute to their varying effectiveness?} % Author name and email address

\date{\textbf{Words}: not enough} % University, school and/or department name(s) and a date

%----------------------------------------------------------------------------------------

\begin{document}

\doublespacing

\maketitle % Print the title
\thispagestyle{empty}
\pagebreak
\tableofcontents
\thispagestyle{empty}

\clearpage
\pagenumbering{arabic}

\pagebreak
\section{Introduction} % Unnumbered section

The impacts and applications of string matching algorithms extend far beyond their immediate textual applications; its quotidian use in domains such as bioinformatics, web crawling and security systems make it a pertinent area of study within computer science. There is also constant research being carried out to identify more efficient algorithms, and find ways in which to combine them with other disciplines to carry out certain tasks.

For instance, multiple studies have been recently published performing various comparative analyses of new string matching algorithms [5], and their applicability to a wide range of domains such as biological sequences [6], quantum computing [7], and instrusion detection systems [8]. These findings indicate the modern-day relevance and applicability of string matching algorithms and demonstrate its worthiness as a subject of investigation.

Similarly, this paper seeks to adopt an investigative style by examining \textbf{how different string matching algorithms perform across various application domains, and the factors that contribute to their varying effectiveness}. The choice of this research question is both relevant and justifiable, reflecting the persistent demand for evaluating and optimizing string matching algorithms across a range of applications.

To examine this subject, three popular string matching algorithms were programmed and tested on their ability to carry out three tasks from three different domains. They are then evaluated on their efficiency, and applicability. To maintain focus on the research question, the reasoning and rationale behind all the decisions will be explained to demonstrate how they directly address the question.

\section{Theoretical Background} % Numbered section
\subsection{Topic Overview}
String matching algorithms (often used interchangeably with string or pattern searching
algorithms) are a subset of string algorithms. The term is composed of three parts:
“string”, “matching”, and “algorithm”. Strings refer to an abstract data type consisting
1
of a sequence of characters. Matching relates to it's function to identify specific patterns
within a larger dataset that match a criteria. As for algorithms, these can be defined as a set of instructions designed to carry out a function. These algorithms take in two
inputs: a pattern ($P$), which is a sequence of characters being searched for within a larger
sequence, a text ($T$). Within string matching problems, there exists two general variants
[2]:

\begin{enumerate}
	\item \textbf{Find occurences of a pre-defined pattern in a previously unseen dataset} \\
	Carried out using finite automata models [4] (an idealized machine used to recognize
	patterns in a given text; it accepts or rejects the input depending on whether the
	pre-defined pattern occurs in the text) or through the combinatorial properties of
	strings.
	\item \textbf{Find occurences of any identifiable patterns in a given text} \\
	Carried out using finite automata and binary trees.
\end{enumerate}

Linking into the mentioned problem variants, these algorithms can be further classified into two categories [1]: exact, and approximate string matching algorithms. As
its name suggests, the former refers to finding occurences of a pattern that match it to
the character, whereas the latter allows for some variation or deviation. For the purpose
of this investigation, the first problem variant, as well as an exact-string matching approach was chosen for all the algorithms, both for simplicity and control. Three exact
string matching algorithms were chosen for comparison based on their popularity: Naive,
Knuth-Morris-Pratt, and Rabin-Karp. Prior to their explanations, it is important to note
that the following notation will be used:

\begin{table}[htbp]\caption{String Matching Algorithm Notation}
\begin{center}% used the environment to augment the vertical space
% between the caption and the table
\begin{tabular}{r c p{10cm} }
\toprule
$m$ & $=$ & Length of $P$\\
$n$ & $=$ & Length of $T$\\
$T_{j}$ & : & For an input text $T$ where $0 \le j \le n - 1$\\
$P_{i}$ & : & For an input pattern $P$ where $0 \le i \le m - 1$\\
\bottomrule
\end{tabular}
\end{center}
\label{tab:StringMatchinAlgorithmNotation}
\end{table}

\subsection{Naive Algorithm}

[9] Also known as the “brute-force” approach, this algorithm compares the first indexes
of both $P$ and $T$. If $P_{i}$ equals $T_{j}$ then $i$ and $j$ are incremented and further compared. If
$P_{i}$ reaches $m - 1$ then a variable containing the number of occurences of $P$ is incremented
and $P_{i}$ is reset to $P_{i=0}$. On the other hand, if they do not match, then $P_{i}$ is reset and
$j$ incremented. This repeats until $T_{j=m-1}$ is reached. Since there is no pre-processing
phase, the only time complexity taken into account is during its matching phase, which
is expected to be $O(n \cdot m)$ [10]. The algorithm is better expressed in pseudocode:

\begin{center}
\begin{singlespace}
\begin{minipage}{0.75\linewidth}
\begin{algorithm}[H]
	$n \leftarrow T.length()$ \;
	$m \leftarrow P.length()$ \;
	\For{$i \leftarrow 0$ \bf{to} $n-m$}{
		\While{$j < m$ \bf{and} $P[j] == T[i+j]$}{
			$j \leftarrow j + 1$}
		\If{$j == m$}{
			\textbf{output} "Pattern found at index" + $i$}
	}
	\caption{Naive}
\end{algorithm}
\end{minipage}
\end{singlespace}
\end{center}

The best case scenario of this process is when $P_{i=0}$ is not present in $T$, yielding an
$O(n)$ number of comparisons, making it particularly advantageous for solving problems
with small $n$ and $m$ values. When larger sets are used however, the algorithm's efficiency significantly deteriorates. The worst case scenario for instance would be when
all the characters for $P$ and $T$ are the same (${P_{i=0} \ldots P_{m-1}} = {T_{j=0} \ldots T_{n-1}}$) or
when all the characters for both $P$ and $T$ are the same except for their last characters ($({P_{i=0} \ldots P_{m-2}} = {T_{j=0} \ldots T_{n-2}}) \land (P_{m-1} = T_{n-1})$). This would yield an
$O(m \cdot (n - m + 1))$ number of comparisons.

\subsection{Knuth-Morris-Pratt Algorithm}

[10] [11] This algorithm differs from the Naive approach by implementing an LPS table
as part of the pre-processing phase. Its purpose is to keep track of the comparisons made;
after a mismatch, it is used to calculate where to begin the next match without needing
to reset $P$. The table is constructed by determining the largest prefix of $P$ that matches
its largest suffix -- the main idea is to identify how many characters can be skipped, by not
matching characters that have already been calculated to match (eliminating redundancy).
Although appearing complicated, this can be better explained through pseudocode and a
practical example represented through a truth table. Upon initalization, the LPS table is
an array of 0s of length $m$. For demonstration purposes, $P$ will equal "$ABABA$":

\begin{table}[!htbp]
    \centering
    \begin{tabular}{|c|c|c|c|}
        \hline
        Index ($i$) & Pattern Character ($P_{i}$) & Length (of Suffix-Prefix match) & LPS Value ($LPS[i]$) \\
        \hline
        0 & A & 0 & 0 \\
        1 & B & 0 & 0 \\
        2 & A & 0 & 1 \\
        3 & B & 1 & 2 \\
        4 & A & 2 & 3 \\
        \hline
    \end{tabular}
    \caption{Truth Table for Pattern "ABABA"}
\end{table}

\begin{center}
\begin{singlespace}
\begin{minipage}{0.75\linewidth}
\begin{algorithm}[H]
	$length \leftarrow 0$ \;
	$LPS \leftarrow m * [0]$ \;
	\While{$i < m$}{
		\If{$P[i] == P[m]$}{
			$length \leftarrow length + 1$\;
			$LPS[i] \leftarrow 0$\;
			$i \leftarrow i + 1$\;
		}
		\ElseIf{$length \neq 0$}{
			$length \leftarrow LPS[length - 1]$\;
		}
		\Else{
			$LPS[i] \leftarrow 0$\;
			$i \leftarrow i + 1$\;
		}
	}
	\textbf{return} $LPS$
	\caption{CalculateLPSArray}
\end{algorithm}
\end{minipage}
\end{singlespace}
\end{center}

Afterwards, the main phase involves applying the calculated LPS table on $T$. The
indexes $i$ and $j$ both begin at 0, and are incremented while $P_{i}$ matches $T_{j}$. When a
mismatch occurs, it becomes apparent that the characters in $P$ match with the characters
of $T$ up to the mismatch ($P_{0 \ldots (i-1)} = T_{j-i \ldots j-1}$). Moreover, from the LPS table, it is known
that $LPS[i - 1]$ represents the length of the longest part of the prefix and suffix of $P$.
With these pieces of information, it can be concluded that the characters in $P_{0 \ldots i-1}$ do
not need to be checked with $T_{j-i \ldots j-1}$ since it is already known that they match. Thus,
these can be skipped in both $P$ and $T$. The exact process is presented in pseudocode here
below:

\begin{center}
\begin{singlespace}
\begin{minipage}{0.75\linewidth}
\begin{algorithm}[H]
	$length \leftarrow 0$ \;
	$LPS \leftarrow m * [0]$ \;
	\While{$i < m$}{
		\If{$P[i] == P[m]$}{
			$length \leftarrow length + 1$\;
			$LPS[i] \leftarrow 0$\;
			$i \leftarrow i + 1$\;
		}
		\ElseIf{$length \neq 0$}{
			$length \leftarrow LPS[length - 1]$\;
		}
		\Else{
			$LPS[i] \leftarrow 0$\;
			$i \leftarrow i + 1$\;
		}
	}
	\textbf{return} $LPS$
	\caption{CalculateLPSArray}
\end{algorithm}
\end{minipage}
\end{singlespace}
\end{center}

\subsection{Rabin-Karp Algorithm}


\section{Experimental Methodology}

\subsection{Research Question Decomposition}

\subsection{Measuring Performance}

\subsection{Application to Domains}


\section{Experimental Results Analysis}

\section{Conclusion}

\section{References}





% Numbered question, with an optional title
\begin{question}[\itshape (with optional title)]
	In congue risus leo, in gravida enim viverra id. Donec eros mauris, bibendum vel dui at, tempor commodo augue. In vel lobortis lacus. Nam ornare ullamcorper mauris vel molestie. Maecenas vehicula ornare turpis, vitae fringilla orci consectetur vel. Nam pulvinar justo nec neque egestas tristique. Donec ac dolor at libero congue varius sed vitae lectus. Donec et tristique nulla, sit amet scelerisque orci. Maecenas a vestibulum lectus, vitae gravida nulla. Proin eget volutpat orci. Morbi eu aliquet turpis. Vivamus molestie urna quis tempor tristique. Proin hendrerit sem nec tempor sollicitudin.
\end{question}


\end{document}
